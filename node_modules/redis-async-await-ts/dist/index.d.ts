/// <reference types="node" />
import redis from 'redis';
export declare const init: (url?: string) => void;
export declare const client: {
    get: <T = any>(key: string) => Promise<T>;
    set: <T_1 = string>(key: string, value: T_1) => Promise<void>;
    connected: boolean;
    command_queue_length: number;
    offline_queue_length: number;
    retry_delay: number | Error;
    retry_backoff: number;
    command_queue: any[];
    offline_queue: any[];
    connection_id: number;
    server_info: redis.ServerInfo;
    stream: import("stream").Duplex;
    on(event: "message" | "message_buffer", listener: (channel: string, message: string) => void): redis.RedisClient;
    on(event: "pmessage" | "pmessage_buffer", listener: (pattern: string, channel: string, message: string) => void): redis.RedisClient;
    on(event: "subscribe" | "unsubscribe", listener: (channel: string, count: number) => void): redis.RedisClient;
    on(event: "psubscribe" | "punsubscribe", listener: (pattern: string, count: number) => void): redis.RedisClient;
    on(event: string, listener: (...args: any[]) => void): redis.RedisClient;
    end(flush?: boolean | undefined): void;
    unref(): void;
    cork(): void;
    uncork(): void;
    duplicate(options?: redis.ClientOpts | undefined, cb?: redis.Callback<redis.RedisClient> | undefined): redis.RedisClient;
    sendCommand(command: string, cb?: redis.Callback<any> | undefined): boolean;
    sendCommand(command: string, args?: any[] | undefined, cb?: redis.Callback<any> | undefined): boolean;
    send_command(command: string, cb?: redis.Callback<any> | undefined): boolean;
    send_command(command: string, args?: any[] | undefined, cb?: redis.Callback<any> | undefined): boolean;
    multi(args?: (string | number | redis.Callback<any>)[][] | undefined): redis.Multi;
    MULTI(args?: (string | number | redis.Callback<any>)[][] | undefined): redis.Multi;
    batch(args?: (string | number | redis.Callback<any>)[][] | undefined): redis.Multi;
    BATCH(args?: (string | number | redis.Callback<any>)[][] | undefined): redis.Multi;
    monitor(cb?: redis.Callback<undefined> | undefined): boolean;
    MONITOR(cb?: redis.Callback<undefined> | undefined): boolean;
    info(cb?: redis.Callback<redis.ServerInfo> | undefined): boolean;
    info(section?: string | string[] | undefined, cb?: redis.Callback<redis.ServerInfo> | undefined): boolean;
    INFO(cb?: redis.Callback<redis.ServerInfo> | undefined): boolean;
    INFO(section?: string | string[] | undefined, cb?: redis.Callback<redis.ServerInfo> | undefined): boolean;
    ping(callback?: redis.Callback<string> | undefined): boolean;
    ping(message: string, callback?: redis.Callback<string> | undefined): boolean;
    PING(callback?: redis.Callback<string> | undefined): boolean;
    PING(message: string, callback?: redis.Callback<string> | undefined): boolean;
    publish(channel: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    PUBLISH(channel: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    auth(password: string, callback?: redis.Callback<string> | undefined): boolean;
    AUTH(password: string, callback?: redis.Callback<string> | undefined): boolean;
    client: redis.OverloadedCommand<string, any, boolean>;
    CLIENT: redis.OverloadedCommand<string, any, boolean>;
    hmset: redis.OverloadedSetCommand<string | number, "OK", boolean>;
    HMSET: redis.OverloadedSetCommand<string | number, "OK", boolean>;
    subscribe: redis.OverloadedListCommand<string, string, boolean>;
    SUBSCRIBE: redis.OverloadedListCommand<string, string, boolean>;
    unsubscribe: redis.OverloadedListCommand<string, string, boolean>;
    UNSUBSCRIBE: redis.OverloadedListCommand<string, string, boolean>;
    psubscribe: redis.OverloadedListCommand<string, string, boolean>;
    PSUBSCRIBE: redis.OverloadedListCommand<string, string, boolean>;
    punsubscribe: redis.OverloadedListCommand<string, string, boolean>;
    PUNSUBSCRIBE: redis.OverloadedListCommand<string, string, boolean>;
    append(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    APPEND(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    bgrewriteaof(cb?: redis.Callback<"OK"> | undefined): boolean;
    BGREWRITEAOF(cb?: redis.Callback<"OK"> | undefined): boolean;
    bgsave(cb?: redis.Callback<string> | undefined): boolean;
    BGSAVE(cb?: redis.Callback<string> | undefined): boolean;
    bitcount(key: string, cb?: redis.Callback<number> | undefined): boolean;
    bitcount(key: string, start: number, end: number, cb?: redis.Callback<number> | undefined): boolean;
    BITCOUNT(key: string, cb?: redis.Callback<number> | undefined): boolean;
    BITCOUNT(key: string, start: number, end: number, cb?: redis.Callback<number> | undefined): boolean;
    bitfield: redis.OverloadedKeyCommand<string | number, number[], boolean>;
    BITFIELD: redis.OverloadedKeyCommand<string | number, number[], boolean>;
    bitop(operation: string, destkey: string, key1: string, key2: string, key3: string, cb?: redis.Callback<number> | undefined): boolean;
    bitop(operation: string, destkey: string, key1: string, key2: string, cb?: redis.Callback<number> | undefined): boolean;
    bitop(operation: string, destkey: string, key: string, cb?: redis.Callback<number> | undefined): boolean;
    bitop(operation: string, destkey: string, ...args: (string | redis.Callback<number>)[]): boolean;
    BITOP(operation: string, destkey: string, key1: string, key2: string, key3: string, cb?: redis.Callback<number> | undefined): boolean;
    BITOP(operation: string, destkey: string, key1: string, key2: string, cb?: redis.Callback<number> | undefined): boolean;
    BITOP(operation: string, destkey: string, key: string, cb?: redis.Callback<number> | undefined): boolean;
    BITOP(operation: string, destkey: string, ...args: (string | redis.Callback<number>)[]): boolean;
    bitpos(key: string, bit: number, start: number, end: number, cb?: redis.Callback<number> | undefined): boolean;
    bitpos(key: string, bit: number, start: number, cb?: redis.Callback<number> | undefined): boolean;
    bitpos(key: string, bit: number, cb?: redis.Callback<number> | undefined): boolean;
    BITPOS(key: string, bit: number, start: number, end: number, cb?: redis.Callback<number> | undefined): boolean;
    BITPOS(key: string, bit: number, start: number, cb?: redis.Callback<number> | undefined): boolean;
    BITPOS(key: string, bit: number, cb?: redis.Callback<number> | undefined): boolean;
    blpop: redis.OverloadedLastCommand<string, number, [string, string], boolean>;
    BLPOP: redis.OverloadedLastCommand<string, number, [string, string], boolean>;
    brpop: redis.OverloadedLastCommand<string, number, [string, string], boolean>;
    BRPOP: redis.OverloadedLastCommand<string, number, [string, string], boolean>;
    brpoplpush(source: string, destination: string, timeout: number, cb?: redis.Callback<string | null> | undefined): boolean;
    BRPOPLPUSH(source: string, destination: string, timeout: number, cb?: redis.Callback<string | null> | undefined): boolean;
    cluster: redis.OverloadedCommand<string, any, redis.RedisClient>;
    CLUSTER: redis.OverloadedCommand<string, any, redis.RedisClient>;
    command(cb?: redis.Callback<[string, number, string[], number, number, number][]> | undefined): boolean;
    COMMAND(cb?: redis.Callback<[string, number, string[], number, number, number][]> | undefined): boolean;
    config: redis.OverloadedCommand<string, boolean, boolean>;
    CONFIG: redis.OverloadedCommand<string, boolean, boolean>;
    dbsize(cb?: redis.Callback<number> | undefined): boolean;
    DBSIZE(cb?: redis.Callback<number> | undefined): boolean;
    debug: redis.OverloadedCommand<string, boolean, boolean>;
    DEBUG: redis.OverloadedCommand<string, boolean, boolean>;
    decr(key: string, cb?: redis.Callback<number> | undefined): boolean;
    DECR(key: string, cb?: redis.Callback<number> | undefined): boolean;
    decrby(key: string, decrement: number, cb?: redis.Callback<number> | undefined): boolean;
    DECRBY(key: string, decrement: number, cb?: redis.Callback<number> | undefined): boolean;
    del: redis.OverloadedCommand<string, number, boolean>;
    DEL: redis.OverloadedCommand<string, number, boolean>;
    discard(cb?: redis.Callback<"OK"> | undefined): boolean;
    DISCARD(cb?: redis.Callback<"OK"> | undefined): boolean;
    dump(key: string, cb?: redis.Callback<string> | undefined): boolean;
    DUMP(key: string, cb?: redis.Callback<string> | undefined): boolean;
    echo<T_2 extends string>(message: T_2, cb?: redis.Callback<T_2> | undefined): boolean;
    ECHO<T_3 extends string>(message: T_3, cb?: redis.Callback<T_3> | undefined): boolean;
    eval: redis.OverloadedCommand<string | number, any, boolean>;
    EVAL: redis.OverloadedCommand<string | number, any, boolean>;
    evalsha: redis.OverloadedCommand<string | number, any, boolean>;
    EVALSHA: redis.OverloadedCommand<string | number, any, boolean>;
    exists: redis.OverloadedCommand<string, number, boolean>;
    EXISTS: redis.OverloadedCommand<string, number, boolean>;
    expire(key: string, seconds: number, cb?: redis.Callback<number> | undefined): boolean;
    EXPIRE(key: string, seconds: number, cb?: redis.Callback<number> | undefined): boolean;
    expireat(key: string, timestamp: number, cb?: redis.Callback<number> | undefined): boolean;
    EXPIREAT(key: string, timestamp: number, cb?: redis.Callback<number> | undefined): boolean;
    flushall(cb?: redis.Callback<string> | undefined): boolean;
    flushall(async: "ASYNC", cb?: redis.Callback<string> | undefined): boolean;
    FLUSHALL(cb?: redis.Callback<string> | undefined): boolean;
    FLUSHALL(async: "ASYNC", cb?: redis.Callback<string> | undefined): boolean;
    flushdb(cb?: redis.Callback<"OK"> | undefined): boolean;
    flushdb(async: "ASYNC", cb?: redis.Callback<string> | undefined): boolean;
    FLUSHDB(cb?: redis.Callback<"OK"> | undefined): boolean;
    FLUSHDB(async: "ASYNC", cb?: redis.Callback<string> | undefined): boolean;
    geoadd: redis.OverloadedKeyCommand<string | number, number, boolean>;
    GEOADD: redis.OverloadedKeyCommand<string | number, number, boolean>;
    geohash: redis.OverloadedKeyCommand<string, string, boolean>;
    GEOHASH: redis.OverloadedKeyCommand<string, string, boolean>;
    geopos: redis.OverloadedKeyCommand<string, [number, number][], boolean>;
    GEOPOS: redis.OverloadedKeyCommand<string, [number, number][], boolean>;
    geodist: redis.OverloadedKeyCommand<string, string, boolean>;
    GEODIST: redis.OverloadedKeyCommand<string, string, boolean>;
    georadius: redis.OverloadedKeyCommand<string | number, (string | [string, string | [string, string]])[], boolean>;
    GEORADIUS: redis.OverloadedKeyCommand<string | number, (string | [string, string | [string, string]])[], boolean>;
    georadiusbymember: redis.OverloadedKeyCommand<string | number, (string | [string, string | [string, string]])[], boolean>;
    GEORADIUSBYMEMBER: redis.OverloadedKeyCommand<string | number, (string | [string, string | [string, string]])[], boolean>;
    GET(key: string, cb?: redis.Callback<string | null> | undefined): boolean;
    getbit(key: string, offset: number, cb?: redis.Callback<number> | undefined): boolean;
    GETBIT(key: string, offset: number, cb?: redis.Callback<number> | undefined): boolean;
    getrange(key: string, start: number, end: number, cb?: redis.Callback<string> | undefined): boolean;
    GETRANGE(key: string, start: number, end: number, cb?: redis.Callback<string> | undefined): boolean;
    getset(key: string, value: string, cb?: redis.Callback<string> | undefined): boolean;
    GETSET(key: string, value: string, cb?: redis.Callback<string> | undefined): boolean;
    hdel: redis.OverloadedKeyCommand<string, number, boolean>;
    HDEL: redis.OverloadedKeyCommand<string, number, boolean>;
    hexists(key: string, field: string, cb?: redis.Callback<number> | undefined): boolean;
    HEXISTS(key: string, field: string, cb?: redis.Callback<number> | undefined): boolean;
    hget(key: string, field: string, cb?: redis.Callback<string> | undefined): boolean;
    HGET(key: string, field: string, cb?: redis.Callback<string> | undefined): boolean;
    hgetall(key: string, cb?: redis.Callback<{
        [key: string]: string;
    }> | undefined): boolean;
    HGETALL(key: string, cb?: redis.Callback<{
        [key: string]: string;
    }> | undefined): boolean;
    hincrby(key: string, field: string, increment: number, cb?: redis.Callback<number> | undefined): boolean;
    HINCRBY(key: string, field: string, increment: number, cb?: redis.Callback<number> | undefined): boolean;
    hincrbyfloat(key: string, field: string, increment: number, cb?: redis.Callback<string> | undefined): boolean;
    HINCRBYFLOAT(key: string, field: string, increment: number, cb?: redis.Callback<string> | undefined): boolean;
    hkeys(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    HKEYS(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    hlen(key: string, cb?: redis.Callback<number> | undefined): boolean;
    HLEN(key: string, cb?: redis.Callback<number> | undefined): boolean;
    hmget: redis.OverloadedKeyCommand<string, string[], boolean>;
    HMGET: redis.OverloadedKeyCommand<string, string[], boolean>;
    hset: redis.OverloadedSetCommand<string, number, boolean>;
    HSET: redis.OverloadedSetCommand<string, number, boolean>;
    hsetnx(key: string, field: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    HSETNX(key: string, field: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    hstrlen(key: string, field: string, cb?: redis.Callback<number> | undefined): boolean;
    HSTRLEN(key: string, field: string, cb?: redis.Callback<number> | undefined): boolean;
    hvals(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    HVALS(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    incr(key: string, cb?: redis.Callback<number> | undefined): boolean;
    INCR(key: string, cb?: redis.Callback<number> | undefined): boolean;
    incrby(key: string, increment: number, cb?: redis.Callback<number> | undefined): boolean;
    INCRBY(key: string, increment: number, cb?: redis.Callback<number> | undefined): boolean;
    incrbyfloat(key: string, increment: number, cb?: redis.Callback<string> | undefined): boolean;
    INCRBYFLOAT(key: string, increment: number, cb?: redis.Callback<string> | undefined): boolean;
    keys(pattern: string, cb?: redis.Callback<string[]> | undefined): boolean;
    KEYS(pattern: string, cb?: redis.Callback<string[]> | undefined): boolean;
    lastsave(cb?: redis.Callback<number> | undefined): boolean;
    LASTSAVE(cb?: redis.Callback<number> | undefined): boolean;
    lindex(key: string, index: number, cb?: redis.Callback<string> | undefined): boolean;
    LINDEX(key: string, index: number, cb?: redis.Callback<string> | undefined): boolean;
    linsert(key: string, dir: "BEFORE" | "AFTER", pivot: string, value: string, cb?: redis.Callback<string> | undefined): boolean;
    LINSERT(key: string, dir: "BEFORE" | "AFTER", pivot: string, value: string, cb?: redis.Callback<string> | undefined): boolean;
    llen(key: string, cb?: redis.Callback<number> | undefined): boolean;
    LLEN(key: string, cb?: redis.Callback<number> | undefined): boolean;
    lpop(key: string, cb?: redis.Callback<string> | undefined): boolean;
    LPOP(key: string, cb?: redis.Callback<string> | undefined): boolean;
    lpush: redis.OverloadedKeyCommand<string, number, boolean>;
    LPUSH: redis.OverloadedKeyCommand<string, number, boolean>;
    lpushx(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    LPUSHX(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    lrange(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    LRANGE(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    lrem(key: string, count: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    LREM(key: string, count: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    lset(key: string, index: number, value: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    LSET(key: string, index: number, value: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    ltrim(key: string, start: number, stop: number, cb?: redis.Callback<"OK"> | undefined): boolean;
    LTRIM(key: string, start: number, stop: number, cb?: redis.Callback<"OK"> | undefined): boolean;
    mget: redis.OverloadedCommand<string, string[], boolean>;
    MGET: redis.OverloadedCommand<string, string[], boolean>;
    migrate: redis.OverloadedCommand<string, boolean, boolean>;
    MIGRATE: redis.OverloadedCommand<string, boolean, boolean>;
    move(key: string, db: string | number): boolean;
    MOVE(key: string, db: string | number): boolean;
    mset: redis.OverloadedCommand<string, boolean, boolean>;
    MSET: redis.OverloadedCommand<string, boolean, boolean>;
    msetnx: redis.OverloadedCommand<string, boolean, boolean>;
    MSETNX: redis.OverloadedCommand<string, boolean, boolean>;
    object: redis.OverloadedCommand<string, any, boolean>;
    OBJECT: redis.OverloadedCommand<string, any, boolean>;
    persist(key: string, cb?: redis.Callback<number> | undefined): boolean;
    PERSIST(key: string, cb?: redis.Callback<number> | undefined): boolean;
    pexpire(key: string, milliseconds: number, cb?: redis.Callback<number> | undefined): boolean;
    PEXPIRE(key: string, milliseconds: number, cb?: redis.Callback<number> | undefined): boolean;
    pexpireat(key: string, millisecondsTimestamp: number, cb?: redis.Callback<number> | undefined): boolean;
    PEXPIREAT(key: string, millisecondsTimestamp: number, cb?: redis.Callback<number> | undefined): boolean;
    pfadd: redis.OverloadedKeyCommand<string, number, boolean>;
    PFADD: redis.OverloadedKeyCommand<string, number, boolean>;
    pfcount: redis.OverloadedCommand<string, number, boolean>;
    PFCOUNT: redis.OverloadedCommand<string, number, boolean>;
    pfmerge: redis.OverloadedCommand<string, boolean, boolean>;
    PFMERGE: redis.OverloadedCommand<string, boolean, boolean>;
    psetex(key: string, milliseconds: number, value: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    PSETEX(key: string, milliseconds: number, value: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    pubsub: redis.OverloadedCommand<string, number, boolean>;
    PUBSUB: redis.OverloadedCommand<string, number, boolean>;
    pttl(key: string, cb?: redis.Callback<number> | undefined): boolean;
    PTTL(key: string, cb?: redis.Callback<number> | undefined): boolean;
    quit(cb?: redis.Callback<"OK"> | undefined): boolean;
    QUIT(cb?: redis.Callback<"OK"> | undefined): boolean;
    randomkey(cb?: redis.Callback<string> | undefined): boolean;
    RANDOMKEY(cb?: redis.Callback<string> | undefined): boolean;
    readonly(cb?: redis.Callback<string> | undefined): boolean;
    READONLY(cb?: redis.Callback<string> | undefined): boolean;
    readwrite(cb?: redis.Callback<string> | undefined): boolean;
    READWRITE(cb?: redis.Callback<string> | undefined): boolean;
    rename(key: string, newkey: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    RENAME(key: string, newkey: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    renamenx(key: string, newkey: string, cb?: redis.Callback<number> | undefined): boolean;
    RENAMENX(key: string, newkey: string, cb?: redis.Callback<number> | undefined): boolean;
    restore(key: string, ttl: number, serializedValue: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    RESTORE(key: string, ttl: number, serializedValue: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    role(cb?: redis.Callback<[string, number, [string, string, string][]]> | undefined): boolean;
    ROLE(cb?: redis.Callback<[string, number, [string, string, string][]]> | undefined): boolean;
    rpop(key: string, cb?: redis.Callback<string> | undefined): boolean;
    RPOP(key: string, cb?: redis.Callback<string> | undefined): boolean;
    rpoplpush(source: string, destination: string, cb?: redis.Callback<string> | undefined): boolean;
    RPOPLPUSH(source: string, destination: string, cb?: redis.Callback<string> | undefined): boolean;
    rpush: redis.OverloadedKeyCommand<string, number, boolean>;
    RPUSH: redis.OverloadedKeyCommand<string, number, boolean>;
    rpushx(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    RPUSHX(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    sadd: redis.OverloadedKeyCommand<string, number, boolean>;
    SADD: redis.OverloadedKeyCommand<string, number, boolean>;
    save(cb?: redis.Callback<string> | undefined): boolean;
    SAVE(cb?: redis.Callback<string> | undefined): boolean;
    scard(key: string, cb?: redis.Callback<number> | undefined): boolean;
    SCARD(key: string, cb?: redis.Callback<number> | undefined): boolean;
    script: redis.OverloadedCommand<string, any, boolean>;
    SCRIPT: redis.OverloadedCommand<string, any, boolean>;
    sdiff: redis.OverloadedCommand<string, string[], boolean>;
    SDIFF: redis.OverloadedCommand<string, string[], boolean>;
    sdiffstore: redis.OverloadedKeyCommand<string, number, boolean>;
    SDIFFSTORE: redis.OverloadedKeyCommand<string, number, boolean>;
    select(index: string | number, cb?: redis.Callback<string> | undefined): boolean;
    SELECT(index: string | number, cb?: redis.Callback<string> | undefined): boolean;
    SET(key: string, value: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    SET(key: string, value: string, flag: string, cb?: redis.Callback<"OK"> | undefined): boolean;
    SET(key: string, value: string, mode: string, duration: number, cb?: redis.Callback<"OK" | undefined> | undefined): boolean;
    SET(key: string, value: string, mode: string, duration: number, flag: string, cb?: redis.Callback<"OK" | undefined> | undefined): boolean;
    SET(key: string, value: string, flag: string, mode: string, duration: number, cb?: redis.Callback<"OK" | undefined> | undefined): boolean;
    setbit(key: string, offset: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    SETBIT(key: string, offset: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    setex(key: string, seconds: number, value: string, cb?: redis.Callback<string> | undefined): boolean;
    SETEX(key: string, seconds: number, value: string, cb?: redis.Callback<string> | undefined): boolean;
    setnx(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    SETNX(key: string, value: string, cb?: redis.Callback<number> | undefined): boolean;
    setrange(key: string, offset: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    SETRANGE(key: string, offset: number, value: string, cb?: redis.Callback<number> | undefined): boolean;
    shutdown: redis.OverloadedCommand<string, string, boolean>;
    SHUTDOWN: redis.OverloadedCommand<string, string, boolean>;
    sinter: redis.OverloadedKeyCommand<string, string[], boolean>;
    SINTER: redis.OverloadedKeyCommand<string, string[], boolean>;
    sinterstore: redis.OverloadedCommand<string, number, boolean>;
    SINTERSTORE: redis.OverloadedCommand<string, number, boolean>;
    sismember(key: string, member: string, cb?: redis.Callback<number> | undefined): boolean;
    SISMEMBER(key: string, member: string, cb?: redis.Callback<number> | undefined): boolean;
    slaveof(host: string, port: string | number, cb?: redis.Callback<string> | undefined): boolean;
    SLAVEOF(host: string, port: string | number, cb?: redis.Callback<string> | undefined): boolean;
    slowlog: redis.OverloadedCommand<string, [number, number, number, string[]][], boolean>;
    SLOWLOG: redis.OverloadedCommand<string, [number, number, number, string[]][], boolean>;
    smembers(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    SMEMBERS(key: string, cb?: redis.Callback<string[]> | undefined): boolean;
    smove(source: string, destination: string, member: string, cb?: redis.Callback<number> | undefined): boolean;
    SMOVE(source: string, destination: string, member: string, cb?: redis.Callback<number> | undefined): boolean;
    sort: redis.OverloadedCommand<string, string[], boolean>;
    SORT: redis.OverloadedCommand<string, string[], boolean>;
    spop(key: string, cb?: redis.Callback<string> | undefined): boolean;
    spop(key: string, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    SPOP(key: string, cb?: redis.Callback<string> | undefined): boolean;
    SPOP(key: string, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    srandmember(key: string, cb?: redis.Callback<string> | undefined): boolean;
    srandmember(key: string, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    SRANDMEMBER(key: string, cb?: redis.Callback<string> | undefined): boolean;
    SRANDMEMBER(key: string, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    srem: redis.OverloadedKeyCommand<string, number, boolean>;
    SREM: redis.OverloadedKeyCommand<string, number, boolean>;
    strlen(key: string, cb?: redis.Callback<number> | undefined): boolean;
    STRLEN(key: string, cb?: redis.Callback<number> | undefined): boolean;
    sunion: redis.OverloadedCommand<string, string[], boolean>;
    SUNION: redis.OverloadedCommand<string, string[], boolean>;
    sunionstore: redis.OverloadedCommand<string, number, boolean>;
    SUNIONSTORE: redis.OverloadedCommand<string, number, boolean>;
    sync(cb?: redis.Callback<undefined> | undefined): boolean;
    SYNC(cb?: redis.Callback<undefined> | undefined): boolean;
    time(cb?: redis.Callback<[string, string]> | undefined): boolean;
    TIME(cb?: redis.Callback<[string, string]> | undefined): boolean;
    ttl(key: string, cb?: redis.Callback<number> | undefined): boolean;
    TTL(key: string, cb?: redis.Callback<number> | undefined): boolean;
    type(key: string, cb?: redis.Callback<string> | undefined): boolean;
    TYPE(key: string, cb?: redis.Callback<string> | undefined): boolean;
    unlink: redis.OverloadedCommand<string, number, boolean>;
    UNLINK: redis.OverloadedCommand<string, number, boolean>;
    unwatch(cb?: redis.Callback<"OK"> | undefined): boolean;
    UNWATCH(cb?: redis.Callback<"OK"> | undefined): boolean;
    wait(numslaves: number, timeout: number, cb?: redis.Callback<number> | undefined): boolean;
    WAIT(numslaves: number, timeout: number, cb?: redis.Callback<number> | undefined): boolean;
    watch: redis.OverloadedCommand<string, "OK", boolean>;
    WATCH: redis.OverloadedCommand<string, "OK", boolean>;
    zadd: redis.OverloadedKeyCommand<string | number, number, boolean>;
    ZADD: redis.OverloadedKeyCommand<string | number, number, boolean>;
    zcard(key: string, cb?: redis.Callback<number> | undefined): boolean;
    ZCARD(key: string, cb?: redis.Callback<number> | undefined): boolean;
    zcount(key: string, min: string | number, max: string | number, cb?: redis.Callback<number> | undefined): boolean;
    ZCOUNT(key: string, min: string | number, max: string | number, cb?: redis.Callback<number> | undefined): boolean;
    zincrby(key: string, increment: number, member: string, cb?: redis.Callback<string> | undefined): boolean;
    ZINCRBY(key: string, increment: number, member: string, cb?: redis.Callback<string> | undefined): boolean;
    zinterstore: redis.OverloadedCommand<string | number, number, boolean>;
    ZINTERSTORE: redis.OverloadedCommand<string | number, number, boolean>;
    zlexcount(key: string, min: string, max: string, cb?: redis.Callback<number> | undefined): boolean;
    ZLEXCOUNT(key: string, min: string, max: string, cb?: redis.Callback<number> | undefined): boolean;
    zrange(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrange(key: string, start: number, stop: number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGE(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGE(key: string, start: number, stop: number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebylex(key: string, min: string, max: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebylex(key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYLEX(key: string, min: string, max: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYLEX(key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebylex(key: string, min: string, max: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebylex(key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYLEX(key: string, min: string, max: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYLEX(key: string, min: string, max: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebyscore(key: string, min: string | number, max: string | number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebyscore(key: string, min: string | number, max: string | number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebyscore(key: string, min: string | number, max: string | number, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrangebyscore(key: string, min: string | number, max: string | number, withscores: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYSCORE(key: string, min: string | number, max: string | number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYSCORE(key: string, min: string | number, max: string | number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYSCORE(key: string, min: string | number, max: string | number, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZRANGEBYSCORE(key: string, min: string | number, max: string | number, withscores: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrank(key: string, member: string, cb?: redis.Callback<number | null> | undefined): boolean;
    ZRANK(key: string, member: string, cb?: redis.Callback<number | null> | undefined): boolean;
    zrem: redis.OverloadedKeyCommand<string, number, boolean>;
    ZREM: redis.OverloadedKeyCommand<string, number, boolean>;
    zremrangebylex(key: string, min: string, max: string, cb?: redis.Callback<number> | undefined): boolean;
    ZREMRANGEBYLEX(key: string, min: string, max: string, cb?: redis.Callback<number> | undefined): boolean;
    zremrangebyrank(key: string, start: number, stop: number, cb?: redis.Callback<number> | undefined): boolean;
    ZREMRANGEBYRANK(key: string, start: number, stop: number, cb?: redis.Callback<number> | undefined): boolean;
    zremrangebyscore(key: string, min: string | number, max: string | number, cb?: redis.Callback<number> | undefined): boolean;
    ZREMRANGEBYSCORE(key: string, min: string | number, max: string | number, cb?: redis.Callback<number> | undefined): boolean;
    zrevrange(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrange(key: string, start: number, stop: number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGE(key: string, start: number, stop: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGE(key: string, start: number, stop: number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebyscore(key: string, min: string | number, max: string | number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebyscore(key: string, min: string | number, max: string | number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebyscore(key: string, min: string | number, max: string | number, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrangebyscore(key: string, min: string | number, max: string | number, withscores: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYSCORE(key: string, min: string | number, max: string | number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYSCORE(key: string, min: string | number, max: string | number, withscores: string, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYSCORE(key: string, min: string | number, max: string | number, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    ZREVRANGEBYSCORE(key: string, min: string | number, max: string | number, withscores: string, limit: string, offset: number, count: number, cb?: redis.Callback<string[]> | undefined): boolean;
    zrevrank(key: string, member: string, cb?: redis.Callback<number | null> | undefined): boolean;
    ZREVRANK(key: string, member: string, cb?: redis.Callback<number | null> | undefined): boolean;
    zscore(key: string, member: string, cb?: redis.Callback<string> | undefined): boolean;
    ZSCORE(key: string, member: string, cb?: redis.Callback<string> | undefined): boolean;
    zunionstore: redis.OverloadedCommand<string | number, number, boolean>;
    ZUNIONSTORE: redis.OverloadedCommand<string | number, number, boolean>;
    scan: redis.OverloadedCommand<string, [string, string[]], boolean>;
    SCAN: redis.OverloadedCommand<string, [string, string[]], boolean>;
    sscan: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    SSCAN: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    hscan: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    HSCAN: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    zscan: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    ZSCAN: redis.OverloadedKeyCommand<string, [string, string[]], boolean>;
    addListener(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    once(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    removeListener(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    off(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    removeAllListeners(event?: string | symbol | undefined): redis.RedisClient;
    setMaxListeners(n: number): redis.RedisClient;
    getMaxListeners(): number;
    listeners(eventName: string | symbol): Function[];
    rawListeners(eventName: string | symbol): Function[];
    emit(eventName: string | symbol, ...args: any[]): boolean;
    listenerCount(eventName: string | symbol): number;
    prependListener(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    prependOnceListener(eventName: string | symbol, listener: (...args: any[]) => void): redis.RedisClient;
    eventNames(): (string | symbol)[];
};
